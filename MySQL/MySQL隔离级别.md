#### 事务并发访问的问题

1. **脏读**：读到一个事务没有提交的数据
2. **不可重复读**：一个事务在读取的期间，其他事务在对数据进行update操作后进行提交，当前事务第二次修改的时候数据发送变化被其他的事务修改了
3. **幻读**：一个事务在读取的期间，其他事务在对数据进行delete/insert操作后进行提交，当前事务进行update的时候数据的数量发送变化

**可重复读虽然读取不到其他事务提交之后的内容（快照读）但是进行update 操作会从最新的数据上进行（当前读）**



#### 当前读&快照读

SELECT.... LOCK IN SHARE MODE,UPDATE,DELETE,INSERT都是当前读，它们会读出当前最新版本的数据，并为读出的数据加锁

快照读主要为SELECT  它为不加锁的非阻塞读

在读已提交的隔离级别中，因为存在不可重复读的问题，当前事务的快照读可以读到最新的数据，这在某种程度上是一种缺点，类似于多线程中一个线程操作数据的时候总是期望数据不被修改，如果发生了修改会出现并发访问的异常。解决这个问题一种思路是加锁。对应到数据库中进行串行化，所有的数据不管是读取还是修改都会为数据进行加锁。在多线程中还有一种方式可以做到读写共存，比如CopyOnWriteArrayList，在写操作的时候将数据复制到另一个容器，而读操作读取的是之前的那个容器，实现读写分离。

类比在MySQL中也有相同的实现，可重复读隔离级别就可以做到，在快照读时，读取不到最新的修改数据

#### RC RR下InnoDB的非阻塞读如何实现

在RR下,第一条快照读会创建一个快照，然后每次读取都基于这个快照

而RC下每次读取都会创建一个新的快照



#### RR如何避免幻读

可以依靠Gap  Lock，事务可以使用select ....lock in share mode的方式或者使用update,delete等进行范围的操作会为记录添加gap lock这会防止其他事务对这个范围中的数据进行操作，从而阻止幻读的发生





