

![](https://keyon-edu.oss-cn-beijing.aliyuncs.com/img/TIM%E6%88%AA%E5%9B%BE20200229142352.png)

[详情](https://juejin.im/post/5b82e0196fb9a019f47d1823#heading-5)



##  乐观锁

​      基于版本号实现，在更新数据的时候为了避免冲突要这样操作

``` sql
 update book set book_name='aaa' ,version=version+1
 where book_id=#{id} and version=#{version}
```





## 悲观锁

  悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作（对数据表进行增删改的时候会加锁），悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。**根据分类的方式不同可以分为 共享锁和独占锁，表锁和行锁**



### 共享锁

​        共享锁又称读锁 (read lock)，是读取操作创建的锁（悲观锁由数据库默认实现，读取数据的时候创建共享锁）其他用户可以并发读取数据（可以获取数据上的共享锁），但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。**我没有读完，我不能写，我要继续读，别人可以读，但不能写**

​      如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁（加上共享锁后，对于update，insert，delete**语句会自动加排它锁**，而共享锁再使用排它锁会导致死锁）。获得共享锁的事务只能读数据，不能修改数据，**为什么要使用共享锁呢？主要是为了读取数据不受影响，不会造成幻锁**

  添加共享锁的方式：

              1. 在InnoDB引擎中，在查询语句后面增加 **LOCK IN SHARE MODE ，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。**



### 排它锁

​     exclusive lock（也叫writer lock）又称写锁。若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁（也就是说其他的事务不能读写这个行数据）若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。**排它锁会阻塞所有的排它锁和共享锁**

添加排它锁的方式：

1. 排他锁使用方式：在需要执行的语句后面加上**for update**就可以了 `select status from TABLE where id=1 for update;` 其他的事务如果查询的时候带上for update 会出现阻塞





在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候只锁住一行呢？ **只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

而MyISM引擎只支持表锁，所以在MyISM引擎中加锁lock table 表名 write/read**





**InnoDB如果使用了读锁（lock in share mode） 那么在当前事务未提交之间其他事务不能进行修改但是可以读**

**如果使用了写锁（for update） 那么事务在未提交之间其他事务不能修改，可以查询，但是不能使用for update 进行查询，会进行阻塞，所以在使用for update进行悲观锁时那么所有的查询语句都要加上 for update 不然锁不住**



### 行锁（InnoDB)

​     多个事务操作(修改)同一行数据时，后来的事务处于阻塞等待状态（先前事务自动使用排它锁）。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题



  **InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**





- 行锁的劣势：开销大；加锁慢；会出现死锁
- 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强
- 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：

**虽然会自动加锁吗，但是业务中的修改操作要使用悲观锁的还是要遵守 开启事务 加锁 修改 提交事务的方式，一个更新操作，我们往往要在更新之前就要判断状态（根据id查出商品的数量是否小于0，然后在条件成立的情况下进行更新，在高并发的情境中，根据id查出商品的数量的时候，可能数量会立刻变化，因此在查询的时候我们要是有for update锁住指定的列 然后再更新，而且悲观锁的实现要开启事务，因此可以使用Spring的@Transactionnal注解开启事务）**

**悲观锁适合于高并发修改的情景**

**乐观锁适合于读多于并发写的前景**

y

### 间隙锁

   当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。

InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响

很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！



**危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。**





###  表锁

​        会锁住整张表（很少在代码里使用）

####  表锁中的读锁

​       当前连接为表加读锁后不能修改该表，也不能操作其他表

​       其他的连接可以读取该表，但不能修改加了读锁的表

   **目的：**加读锁的目的是为了读取该表时，该表的数据不会产生变化，防止幻读 **我没有读好，我只能继续读他你们不能写**



####  表锁中的写锁

​         当前连接为表加写锁后，不能操作其他表。但是可以读写当前表

​        其他表也不能读取该表，也不能修改加了写锁的表

**目的**：我要写数据，我没有写好，别人不能读，也不能写





###  行锁（InnoDB)

   锁的是索引而不是数据，如果没有索引会退化为表锁





####  事务

原子性通过undo.log实现

持久性通过redo.log实现

事务的隔离性是通过读写锁和MVCC实现的

事务的一致性是通过隔离性，原子性，持久性实现的

undo.log和redo.log归属于InnoDB引擎

**一致性是事务追求的根本，而事务的并发执行或事务故障，系统故障会破坏一致性，MySQL通过并发控制技术和日志恢复技术来防止这种情况的发生**

并发控制保证了事务的隔离性

日志恢复技术保证了事务的原子性，使一致性状态不会因事务或者系统故障而破坏，同时使已提交的修改不会因系统的崩溃而丢失数据

**可重复读保证了在当前事务中是读不到外界对事务中数据的修改的，只有当两个事务都提交了才可以读到，而幻读是指，当前事务虽然读不到外界的修改值，但Insert 相同的值是会出现重复报错**







